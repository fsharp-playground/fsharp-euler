///Project Euler Problem 61
///Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate 
///(polygonal) numbers and are generated by the following formulae:
///
///Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
///Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
///Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
///Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
///Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
///Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...
///
///The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
///
///   1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
///   2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
///   3. This is the only set of 4-digit numbers with this property.
///
///Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
///triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different 
///number in the set.
//-----------------------------------------------------------------------
// <copyright file="concatprimes.fs" >
// Copyright © 2011 Cesar Mendoza. All rights reserved.
// http://www.kitiara.org
// </copyright>
//-----------------------------------------------------------------------
open System
open Euler2

let triangle n = (n*(n+1))/2

let square n = n*n

let pentagonal n = (n*(3*n-1))/2

let hexagonal n = n*(2*n-1)

let heptagonal n = (n*(5*n-3))/2

let octagonal n = n*(3*n-2)

let (==) a b = 
        let lastTwoDigits n = n % 100
        let fistTwoDigits n = n / 100
        lastTwoDigits a = fistTwoDigits b

let myseq f = 1 |> Seq.unfold(fun next -> 
                                        let t = f next
                                        if t < 10000 then
                                            Some ((t),next+1)
                                        else
                                            None    ) |> Seq.filter(fun (t) -> t > 999 && t < 10000 && t % 100 > 9) |> Seq.toList

let mapPoly a b = [ let candidates = a |> List.map(fun t -> 
                                    let sq = b |> List.filter(fun s -> t == s)
                                    (t,sq))
                    for (t,sq) in candidates do
                      for s in sq do
                          yield (t,s) ]

let remap a b = a |> List.map(snd) |> flip mapPoly b

let test i l = 
    match l with
        | [a; b; c; d; e] ->
                let A = mapPoly i a

                let B = remap A b

                let C = remap B c

                let D = remap C d

                let E = remap D e

                let F = A |> List.map(fst) |> remap E

                if F |> List.isEmpty |> not then
                        let (f,t) = F |> List.head
                        A 
                        |> List.tryFind(fst >> (=) t)
                        |> Option.map snd
                        |> Option.bind(fun s ->
                                B 
                                |> List.tryFind(fst >> (=) s) 
                                |> Option.map snd
                                |> Option.bind(fun p ->
                                    C 
                                    |> List.tryFind(fst >> (=) p)
                                    |> Option.map snd
                                    |> Option.bind(fun hx ->
                                        D 
                                        |> List.tryFind(fst >> (=) hx)
                                        |> Option.map snd
                                        |> Option.bind(fun hp -> 
                                            if hp == f then
                                                Some(t+s+p+hx+hp+f)
                                            else
                                                None
                                        )
                                    )
                                )
                        )
                else
                    None
        | _ -> failwith "error, case not allowed"

let triangles = myseq triangle 

let squares = myseq square

let pentagonals = myseq pentagonal

let hexagonals = myseq hexagonal

let heptagonals = myseq heptagonal

let octagonals = myseq octagonal

let sets = [squares;pentagonals;hexagonals;heptagonals;octagonals]

let solution = sets |> permutations |> Seq.choose (test triangles) |> Seq.head
solution |> printfn "solution: %d"

Console.ReadKey(true) |> ignore
